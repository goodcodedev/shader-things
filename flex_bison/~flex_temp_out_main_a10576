m4_changequote
m4_changequote([[, ]])
m4_define( [[M4_YY_TABLES_VERIFY]], [[[[0]]]])m4_dnl
m4_define( [[M4_YY_PREFIX]], [[[[yy]]]])m4_dnl
m4_define( [[M4_YY_SC_DEFS]], [[[[#define INITIAL 0
]]]])m4_dnl
#line 0 "M4_YY_OUTFILE_NAME"

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */



m4_changecom
m4_changequote
m4_changequote([[, ]])


m4_ifdef( [[M4_YY_IN_HEADER]],,[[m4_dnl
m4_ifelse(M4_YY_PREFIX,yy,,
#define yy_create_buffer M4_YY_PREFIX[[_create_buffer]]
#define yy_delete_buffer M4_YY_PREFIX[[_delete_buffer]]
#define yy_flex_debug M4_YY_PREFIX[[_flex_debug]]
#define yy_init_buffer M4_YY_PREFIX[[_init_buffer]]
#define yy_flush_buffer M4_YY_PREFIX[[_flush_buffer]]
#define yy_load_buffer_state M4_YY_PREFIX[[_load_buffer_state]]
#define yy_switch_to_buffer M4_YY_PREFIX[[_switch_to_buffer]]
#define yyin M4_YY_PREFIX[[in]]
#define yyleng M4_YY_PREFIX[[leng]]
#define yylex M4_YY_PREFIX[[lex]]
#define yylineno M4_YY_PREFIX[[lineno]]
#define yyout M4_YY_PREFIX[[out]]
#define yyrestart M4_YY_PREFIX[[restart]]
#define yytext M4_YY_PREFIX[[text]]
#define yywrap M4_YY_PREFIX[[wrap]]
#define yyalloc M4_YY_PREFIX[[alloc]]
#define yyrealloc M4_YY_PREFIX[[realloc]]
#define yyfree M4_YY_PREFIX[[free]]
)
]])

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 3
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

m4_ifdef( [[M4_YY_IN_HEADER]], , [[m4_define([[M4_YY_NOT_IN_HEADER]], [[]])]])
m4_ifdef( [[M4_YY_REENTRANT]], , [[m4_define([[M4_YY_NOT_REENTRANT]], [[]])]])

m4_ifdef( [[M4_YY_STACK_USED]], [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])
m4_ifdef( [[M4_YY_REENTRANT]],  [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])



m4_ifdef( [[M4_YY_PREFIX]],, [[m4_define([[M4_YY_PREFIX]], [[yy]])]])




    [[#define yy_create_buffer ]]M4_YY_PREFIX[[_create_buffer]]
m4_define([[yy_create_buffer]], [[M4_YY_PREFIX[[_create_buffer]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yy_delete_buffer ]]M4_YY_PREFIX[[_delete_buffer]]
m4_define([[yy_delete_buffer]], [[M4_YY_PREFIX[[_delete_buffer]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yy_scan_buffer ]]M4_YY_PREFIX[[_scan_buffer]]
m4_define([[yy_scan_buffer]], [[M4_YY_PREFIX[[_scan_buffer]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yy_scan_string ]]M4_YY_PREFIX[[_scan_string]]
m4_define([[yy_scan_string]], [[M4_YY_PREFIX[[_scan_string]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yy_scan_bytes ]]M4_YY_PREFIX[[_scan_bytes]]
m4_define([[yy_scan_bytes]], [[M4_YY_PREFIX[[_scan_bytes]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yy_init_buffer ]]M4_YY_PREFIX[[_init_buffer]]
m4_define([[yy_init_buffer]], [[M4_YY_PREFIX[[_init_buffer]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yy_flush_buffer ]]M4_YY_PREFIX[[_flush_buffer]]
m4_define([[yy_flush_buffer]], [[M4_YY_PREFIX[[_flush_buffer]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yy_load_buffer_state ]]M4_YY_PREFIX[[_load_buffer_state]]
m4_define([[yy_load_buffer_state]], [[M4_YY_PREFIX[[_load_buffer_state]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yy_switch_to_buffer ]]M4_YY_PREFIX[[_switch_to_buffer]]
m4_define([[yy_switch_to_buffer]], [[M4_YY_PREFIX[[_switch_to_buffer]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yypush_buffer_state ]]M4_YY_PREFIX[[push_buffer_state]]
m4_define([[yypush_buffer_state]], [[M4_YY_PREFIX[[push_buffer_state]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yypop_buffer_state ]]M4_YY_PREFIX[[pop_buffer_state]]
m4_define([[yypop_buffer_state]], [[M4_YY_PREFIX[[pop_buffer_state]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyensure_buffer_stack ]]M4_YY_PREFIX[[ensure_buffer_stack]]
m4_define([[yyensure_buffer_stack]], [[M4_YY_PREFIX[[ensure_buffer_stack]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yylex ]]M4_YY_PREFIX[[lex]]
m4_define([[yylex]], [[M4_YY_PREFIX[[lex]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyrestart ]]M4_YY_PREFIX[[restart]]
m4_define([[yyrestart]], [[M4_YY_PREFIX[[restart]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yylex_init ]]M4_YY_PREFIX[[lex_init]]
m4_define([[yylex_init]], [[M4_YY_PREFIX[[lex_init]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yylex_init_extra ]]M4_YY_PREFIX[[lex_init_extra]]
m4_define([[yylex_init_extra]], [[M4_YY_PREFIX[[lex_init_extra]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yylex_destroy ]]M4_YY_PREFIX[[lex_destroy]]
m4_define([[yylex_destroy]], [[M4_YY_PREFIX[[lex_destroy]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyget_debug ]]M4_YY_PREFIX[[get_debug]]
m4_define([[yyget_debug]], [[M4_YY_PREFIX[[get_debug]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyset_debug ]]M4_YY_PREFIX[[set_debug]]
m4_define([[yyset_debug]], [[M4_YY_PREFIX[[set_debug]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyget_extra ]]M4_YY_PREFIX[[get_extra]]
m4_define([[yyget_extra]], [[M4_YY_PREFIX[[get_extra]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyset_extra ]]M4_YY_PREFIX[[set_extra]]
m4_define([[yyset_extra]], [[M4_YY_PREFIX[[set_extra]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyget_in ]]M4_YY_PREFIX[[get_in]]
m4_define([[yyget_in]], [[M4_YY_PREFIX[[get_in]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyset_in ]]M4_YY_PREFIX[[set_in]]
m4_define([[yyset_in]], [[M4_YY_PREFIX[[set_in]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyget_out ]]M4_YY_PREFIX[[get_out]]
m4_define([[yyget_out]], [[M4_YY_PREFIX[[get_out]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyset_out ]]M4_YY_PREFIX[[set_out]]
m4_define([[yyset_out]], [[M4_YY_PREFIX[[set_out]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyget_leng ]]M4_YY_PREFIX[[get_leng]]
m4_define([[yyget_leng]], [[M4_YY_PREFIX[[get_leng]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyget_text ]]M4_YY_PREFIX[[get_text]]
m4_define([[yyget_text]], [[M4_YY_PREFIX[[get_text]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyget_lineno ]]M4_YY_PREFIX[[get_lineno]]
m4_define([[yyget_lineno]], [[M4_YY_PREFIX[[get_lineno]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyset_lineno ]]M4_YY_PREFIX[[set_lineno]]
m4_define([[yyset_lineno]], [[M4_YY_PREFIX[[set_lineno]]m4_ifelse($#,0,,[[($@)]])]])
    m4_ifdef( [[M4_YY_REENTRANT]],
    [[
        [[#define yyget_column ]]M4_YY_PREFIX[[get_column]]
m4_define([[yyget_column]], [[M4_YY_PREFIX[[get_column]]m4_ifelse($#,0,,[[($@)]])]])
        [[#define yyset_column ]]M4_YY_PREFIX[[set_column]]
m4_define([[yyset_column]], [[M4_YY_PREFIX[[set_column]]m4_ifelse($#,0,,[[($@)]])]])
    ]])
    [[#define yywrap ]]M4_YY_PREFIX[[wrap]]
m4_define([[yywrap]], [[M4_YY_PREFIX[[wrap]]m4_ifelse($#,0,,[[($@)]])]])

m4_ifdef( [[M4_YY_BISON_LVAL]],
[[
    [[#define yyget_lval ]]M4_YY_PREFIX[[get_lval]]
m4_define([[yyget_lval]], [[M4_YY_PREFIX[[get_lval]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyset_lval ]]M4_YY_PREFIX[[set_lval]]
m4_define([[yyset_lval]], [[M4_YY_PREFIX[[set_lval]]m4_ifelse($#,0,,[[($@)]])]])
]])

m4_ifdef( [[<M4_YY_BISON_LLOC>]],
[[
    [[#define yyget_lloc ]]M4_YY_PREFIX[[get_lloc]]
m4_define([[yyget_lloc]], [[M4_YY_PREFIX[[get_lloc]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyset_lloc ]]M4_YY_PREFIX[[set_lloc]]
m4_define([[yyset_lloc]], [[M4_YY_PREFIX[[set_lloc]]m4_ifelse($#,0,,[[($@)]])]])
]])


    [[#define yyalloc ]]M4_YY_PREFIX[[alloc]]
m4_define([[yyalloc]], [[M4_YY_PREFIX[[alloc]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyrealloc ]]M4_YY_PREFIX[[realloc]]
m4_define([[yyrealloc]], [[M4_YY_PREFIX[[realloc]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyfree ]]M4_YY_PREFIX[[free]]
m4_define([[yyfree]], [[M4_YY_PREFIX[[free]]m4_ifelse($#,0,,[[($@)]])]])

m4_ifdef( [[M4_YY_NOT_REENTRANT]],
[[
    [[#define yytext ]]M4_YY_PREFIX[[text]]
m4_define([[yytext]], [[M4_YY_PREFIX[[text]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyleng ]]M4_YY_PREFIX[[leng]]
m4_define([[yyleng]], [[M4_YY_PREFIX[[leng]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyin ]]M4_YY_PREFIX[[in]]
m4_define([[yyin]], [[M4_YY_PREFIX[[in]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyout ]]M4_YY_PREFIX[[out]]
m4_define([[yyout]], [[M4_YY_PREFIX[[out]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yy_flex_debug ]]M4_YY_PREFIX[[_flex_debug]]
m4_define([[yy_flex_debug]], [[M4_YY_PREFIX[[_flex_debug]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yylineno ]]M4_YY_PREFIX[[lineno]]
m4_define([[yylineno]], [[M4_YY_PREFIX[[lineno]]m4_ifelse($#,0,,[[($@)]])]])
]])


m4_ifdef( [[M4_YY_TABLES_EXTERNAL]],
[[
    [[#define yytables_fload ]]M4_YY_PREFIX[[tables_fload]]
m4_define([[yytables_fload]], [[M4_YY_PREFIX[[tables_fload]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yytables_destroy ]]M4_YY_PREFIX[[tables_destroy]]
m4_define([[yytables_destroy]], [[M4_YY_PREFIX[[tables_destroy]]m4_ifelse($#,0,,[[($@)]])]])
    [[#define yyTABLES_NAME ]]M4_YY_PREFIX[[TABLES_NAME]]
m4_define([[yyTABLES_NAME]], [[M4_YY_PREFIX[[TABLES_NAME]]m4_ifelse($#,0,,[[($@)]])]])
]])

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */



/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

m4_ifdef( [[M4_YY_IN_HEADER]],,[[m4_dnl
/* Returned upon end-of-file. */
#define YY_NULL 0
]])

m4_ifdef( [[M4_YY_IN_HEADER]],,[[m4_dnl
/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
]])







m4_define( [[M4_YY_INCR_LINENO]],
[[
    yylineno++;
]])

m4_define( [[M4_YY_DECL_GUTS_VAR]], [[m4_dnl]])
m4_define( [[M4_YY_NOOP_GUTS_VAR]], [[m4_dnl]])
m4_define( [[YY_G]], [[($1)]])
m4_define( [[M4_YY_PROTO_LAST_ARG]])
m4_define( [[M4_YY_PROTO_ONLY_ARG]],  [[void]])
m4_define( [[M4_YY_DEF_LAST_ARG]])

m4_define( [[M4_YY_DEF_ONLY_ARG]],  [[void]])
m4_define([[M4_YY_DECL_LAST_ARG]])
m4_define([[M4_YY_CALL_LAST_ARG]])
m4_define([[M4_YY_CALL_ONLY_ARG]])
m4_define( [[M4_YY_DOC_PARAM]], )



m4_define( [[YYFARGS1]], [[($1 $2 M4_YY_DEF_LAST_ARG)]])
m4_define( [[YYFARGS2]], [[($1 $2, $3 $4 M4_YY_DEF_LAST_ARG)]])
m4_define( [[YYFARGS3]], [[($1 $2, $3 $4, $5 $6 M4_YY_DEF_LAST_ARG)]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN YY_G(yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((YY_G(yy_start) - 1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin M4_YY_CALL_LAST_ARG )
#define YY_END_OF_BUFFER_CHAR 0
]])

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
]])


#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2
    m4_ifdef( [[M4_YY_USE_LINENO]],
    [[
    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
     *       access to the local variable yy_act. Since yyless() is a macro, it would break
     *       existing scanners that call yyless() from OUTSIDE yylex.
     *       One obvious solution it to make yy_act a global. I tried that, and saw
     *       a 5% performance hit in a non-yylineno scanner, because yy_act is
     *       normally declared as a register variable-- so it is not worth it.
     */
    #define  YY_LESS_LINENO(n) \
            do { \
                int yyl;\
                for ( yyl = n; yyl < yyleng; ++yyl )\
                    if ( yytext[yyl] == '\n' )\
                        --yylineno;\
            }while(0)
    #define YY_LINENO_REWIND_TO(dst) \
            do {\
                const char *p;\
                for ( p = yy_cp-1; p >= (dst); --p)\
                    if ( *p == '\n' )\
                        --yylineno;\
            }while(0)
    ]],
    [[
    #define YY_LESS_LINENO(n)
    #define YY_LINENO_REWIND_TO(ptr)
    ]])
/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = YY_G(yy_hold_char); \
		YY_RESTORE_YY_MORE_OFFSET \
		YY_G(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )
#define unput(c) yyunput( c, YY_G(yytext_ptr) M4_YY_CALL_LAST_ARG )
]])

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
	FILE *yy_input_file;



	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	int yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */


	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;
m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2
]])
	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

m4_ifdef( [[M4_YY_IN_HEADER]],,[[m4_dnl

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( YY_G(yy_buffer_stack) \
                          ? YY_G(yy_buffer_stack)[YY_G(yy_buffer_stack_top)] \
                          : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE YY_G(yy_buffer_stack)[YY_G(yy_buffer_stack_top)]
]])


m4_ifdef( [[M4_YY_IN_HEADER]],,[[m4_dnl
/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars;		/* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = NULL;
static int yy_init = 0;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;
]])

void yyrestart ( FILE *input_file M4_YY_PROTO_LAST_ARG );
void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer M4_YY_PROTO_LAST_ARG );
YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size M4_YY_PROTO_LAST_ARG );
void yy_delete_buffer ( YY_BUFFER_STATE b M4_YY_PROTO_LAST_ARG );
void yy_flush_buffer ( YY_BUFFER_STATE b M4_YY_PROTO_LAST_ARG );
void yypush_buffer_state ( YY_BUFFER_STATE new_buffer M4_YY_PROTO_LAST_ARG );
void yypop_buffer_state ( M4_YY_PROTO_ONLY_ARG );

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
static void yyensure_buffer_stack ( M4_YY_PROTO_ONLY_ARG );
static void yy_load_buffer_state ( M4_YY_PROTO_ONLY_ARG );
static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file M4_YY_PROTO_LAST_ARG );
#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG)
]])

YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size M4_YY_PROTO_LAST_ARG );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str M4_YY_PROTO_LAST_ARG );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len M4_YY_PROTO_LAST_ARG );


void *yyalloc ( yy_size_t M4_YY_PROTO_LAST_ARG );
void *yyrealloc ( void *, yy_size_t M4_YY_PROTO_LAST_ARG );
void yyfree ( void * M4_YY_PROTO_LAST_ARG );

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	}
#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
]])

